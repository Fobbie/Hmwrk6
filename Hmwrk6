# Написать свой cache декоратор c максимальным размером кеша и его очисткой при необходимости.
# Декоратор должен перехватывать аргументы оборачиваемой функции
# Декоратор должен иметь хранилище, где будут сохраняться все перехваченные аргументы и результаты выполнения декорируемой функции
# Декоратор должен проверять наличие перехваченных аргументов в хранилище. Если декорируемая функция уже вызывалась с такими аргументами, она не будет вызываться снова, вместо этого декоратор вернет сохраненное значение.
# Декоратор должен принимать один аргумент - максимальный размер хранилища.
# Если хранилище заполнено, нужно удалить 1 любой элемент, чтобы освободить место под новый.
def do_cache(maxsize):
  cache = {}
  def wrapper(func):
    def args_processing(arg_1, arg_2):
      if (arg_1, arg_2) not in cache.keys():
        if len(cache) == maxsize:
          cache.pop(list(cache.keys())[0])
        cache[(arg_1, arg_2)] = func(arg_1, arg_2)
        return func(arg_1, arg_2)
      else:
        return cache[(arg_1, arg_2)]
    return args_processing
  return wrapper


@do_cache(maxsize = 3)
def get_value(a, b):
  return a ** b


print(get_value(2, 5))
print(get_value(3, 3))
print(get_value(2, 4))
print(get_value(3, 4))
